import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import pickle
from scipy.integrate import odeint
import math
import seaborn as sn


def sir(y, t, beta, rho, nu, gamma,mu, C):
    '''
    Basic SIR model with a compartment for infected and unaware (asymptomatic)
    and a compartment for aware (symptomatic).
    Parameters include transmission rate, beta, social distancing factor, rho,
    transition rate from unaware to aware, nu, and recovery rate, gamma.
    A rate of 0.8% death rate is assumed as it matches local data.
    A sigmoid function is used for the social distancing rate as a way
    to "ramp up" social distancing in a matter of days without breaking
    the ODE.
    '''
    y = np.reshape(y, (5, 8))
    phi = tanh(0.4, rho, t, 43)
    ds = np.zeros(8)
    diu = np.zeros(8)
    dia = np.zeros(8)
    dr = np.zeros(8)
    dd = np.zeros(8)
    for i in range(len(C)):
        for j in range(len(C)):
            ds[i] += -beta*(1-phi)*C[i][j]*y[0][i]*(y[1][j] + y[2][j])
            #S = -b(1-p)s(iu+ia)
            diu[i] += beta*(1-phi)*C[i][j]*y[0][i]*(y[1][j] + y[2][j]) - nu * y[1][i]
            #Iu = -b(1-p)s(iu+ia) - niu
        dia[i] = nu * y[1][i] - gamma*y[2][i] - mu[i]*y[2][i]
        #Ia = nIu - gIa - mIa
        dr[i] = gamma*y[2][i]
        #R = gIa
        dd[i] = mu[i]*y[2][i]
    dy = np.array([ds, diu, dia, dr, dd])
    dy = dy.flatten()
    return dy


def tanh(y0, ym, t, tm):
    '''
    Sigmoid function that starts at 0 and plateaus at ym.
    The half way point between 0 and ym will be achieved at tm.
    '''
    return (ym - y0)*(np.tanh(2. * ((t -tm))/tm) + 1) / 2. + y0


if __name__ == "__main__":
    # Import raw data
    cd_data = pd.read_csv('bc_covid.csv')
    data_rows, data_cols = cd_data.shape
    real_t = np.linspace(0, data_rows-1, data_rows)

    population = pd.read_csv(r'Population_Estimates.csv').values.tolist()
    population = population[0][:-1]
    # Contact rates come from Mossong et al., 2008
    contact_rate = pd.read_csv('contact_rate.csv', index_col=False, header=None).to_numpy()

    # Model conditions
    y_init = np.array([[468921, 521779, 690552, 717836, 646413, 723713, 659506, 642616],
        [0,0,0,0,0,0,0,0],
        [0,0,0,0,1,0,0,0],
        [0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0]])
    # print('{}, {}'.format(y_init, population))
    y0 = y_init.flatten()
    # print('{}, {}'.format(y0, contact_rate[0][2]))
    # t = real_t
    t = np.linspace(0, 180, 181)
    # Retrieve calibrated parameters for model generated by calibration_sir.py
    params = []
    with open('model_params.pkl', 'rb') as file:
        while True:
            try:
                params.append(pickle.load(file))
            except EOFError:
                break
    # print('{}'.format(params))
    # Run ODE 
    y = odeint(sir, y0, t, args=(3**10-8, 0.99, 6/365., 14/365.,
                                [0, 0, 0, 0, 0.04, 0.07, 0.1, 0.13],
                                contact_rate))
    # print('{}'.format(y))
    print('{}'.format(y.shape))
    sol = np.reshape(y, (181, 5, 8))

    plt.plot(t, sol[:, 2, :], '-r', label='Active Cases')
    plt.plot(t, sol[:, 3, :], '-b',  label='Recovered')
    plt.plot(t, sol[:, 4, :], '-g', label='Deaths')
    plt.legend()
    plt.show()